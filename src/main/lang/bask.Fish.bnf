/*
 * Copyright (c) 2021 - 2022 IT-Hock. All rights reserved
 */
{
  parserClass="de.ithock.idea.fishlang.parser.FishParser"
  parserUtilClass="de.ithock.idea.fishlang.psi.impl.FishParserUtil"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Fish"
  psiImplClassSuffix="Impl"
  psiPackage="de.ithock.idea.fishlang.psi"
  psiImplPackage="de.ithock.idea.fishlang.psi.impl"

  elementTypeHolderClass="de.ithock.idea.fishlang.psi.FishElementTypes"
  elementTypeClass="de.ithock.idea.fishlang.psi.FishElementType"
  tokenTypeClass="de.ithock.idea.fishlang.psi.FishTokenType"

  name = "FishLexer"

    tokens = [
        //EOL
        SINGLE_QUOTED_STRING = "regexp:[^\\']'.*([^\\']|\\\\)'"
        DOUBLE_QUOTED_STRING = "regexp:[^\\\"]\".*([^\\]|\\\\)\""

        HEX_NUMBER = "regexp:\\[xX][0-9a-fA-F]+"
        BINARY_NUMBER = "regexp:\\[01]+"
        UNICODE_CHAR = "regexp:\\[uU][0-9a-fA-F]+"
        CHAR = "regexp:\\[cC][0-9]+"
        ESCAPED_VALUE = "regexp:\\[\w~!@#$%\^&*()_+{}|:\"<>?`\-=\[\];',./]"

        DIGIT = "regexp:[0-9]+"
        FLOAT = "regexp:[0-9]+.[0-9]+"

        WILDCARD = "*"
        PIPE = "|"

        LINE_COMMENT = "regexp:([^\\])\s*?#.*"

        TRUE = "true"
        FALSE = "false"

        BEGIN= "begin"
        END = "end"

        FUNCTION = "function"

        IF = "if"
        ELSE = "else"
        WHILE = "while"
        // for X in Y
        FOR = "for"
        IN = "in"
        SWITCH = "switch"
        CASE = "case"
        DEFAULT = "default"
        BREAK = "break"
        CONTINUE = "continue"
        RETURN = "return"

        AND = "and"
        NOT = "not"

        ECHO = "echo"
        SET = "set"
        ABBR = "abbr"
        SOURCE = "source"

        EXIT = "exit"

        BUILTIN_FUNCTION = "regexp:__fish_([A-Za-z0-9_]+)"

        ARG = "regexp:--?[A-Za-z0-9_\-/\\,.]+"
        ENV_VAR = "regexp:\$"
        //ENV_IDENTIFIER = "regexp:\$[a-zA-Z_][a-zA-Z0-9_]*"
        IDENTIFIER = "regexp:[a-zA-Z\d@/_-]+"

        NEWLINE = "regexp:\r?\n"
        TB = "regexp:\t"
        WHITE_SPACE = "regexp:[ ]+"
    ]
}

root ::= <<statements>>* <<eof>>

private <statements> ::= !<<eof>> (
        <<switch_statement>>|<<if_statement>>|<<while_statement>>|<<for_statement>>|
        <<function_definition>>|
        <<builtin_functions>>|<<assignment>>|
        <<code_block>>|<<statement>>|<<echo_function>>|<<command>>|
        CONTINUE|BREAK|RETURN|TRUE|FALSE|AND|<<semicolon>>|<<END_OF_LINE>>)

<END_OF_LINE> ::= NEWLINE|<<eof>>

<env_identifier> ::= (ENV_VAR (IDENTIFIER|BUILTIN_FUNCTION) <<array_access_quanifier>>?)

<integer> ::= DIGIT | DIGIT <<integer>>
<floating_point> ::= FLOAT

<assignment> ::= (<<env_identifier>>|IDENTIFIER) "=" (<<string_literal>>|<<integer>>|<<floating_point>>|
           TRUE|FALSE|IDENTIFIER|<<env_identifier>>)

<array_access_quanifier> ::= '['((<<integer>>'..'<<integer>>|<<integer>>+)|<<string_literal>>)+']'
<array_access> ::= (<<env_identifier>> <<array_access_quanifier>>) | (IDENTIFIER <<array_access_quanifier>>)

<command_identifier> ::= ("[" <<statements>> "]"|IDENTIFIER|<<env_identifier>>|<<array_access>>)
<command> ::= <<command_identifier>> <<arguments>>? <<END_OF_LINE>>

<semicolon> ::= ";"

<inner_command> ::= '(' IDENTIFIER <<arguments>> ')'
<arguments> ::= <<argument>> <<arguments>> | <<argument>>
<argument> ::= <<integer>> | <<floating_point>> |
                <<inner_command>> |
                <<env_identifier>> |
                <<array_access>>
                | (IDENTIFIER ARG)
                | FALSE | TRUE | NOT | AND | PIPE | WILDCARD
                | HEX_NUMBER | BINARY_NUMBER | UNICODE_CHAR | CHAR
                | ARG | "/" | "=" | "&&" | "(" | ")" | "[" | "]" | ">" | "<" | <<semicolon>>
                | (AND (<<command>>|<<builtin_functions>>)) |
                <<command_escape>> | <<command_pipe>> | <<command_wildcard>> | <<string_literal>>

<command_wildcard> ::= WILDCARD
<command_pipe> ::= PIPE
<command_escape> ::= ESCAPED_VALUE

<string_literal> ::= SINGLE_QUOTED_STRING | DOUBLE_QUOTED_STRING | IDENTIFIER | <<env_identifier>>

<echo_function> ::= ECHO (<<arguments>>|">"|"&")* <<END_OF_LINE>>

<function_definition> ::= FUNCTION <<function_name>> <<statements>>* END <<END_OF_LINE>>
<function_name> ::= <<command>>|IDENTIFIER

<expression> ::= NOT? <<command>>|("[" <<command>> "]")|<<builtin_functions>>|
            <<assignment>>|<<code_block>>|<<statement>>|
            <<echo_function>>|<<command>>|<<function_definition>>|
            <<if_statement>>|<<while_statement>>|<<for_statement>>|
            <<switch_statement>> <<END_OF_LINE>>

<statement> ::= <<if_statement>>

<code_block> ::= BEGIN <<statements>>* END

<if_statement> ::= IF <<expression>> <<statements>> (<<END_OF_LINE>>)? (ELSE IF <<statements>>+)* (ELSE <<statements>>+)? END <<END_OF_LINE>>

<for_statement> ::= FOR (IDENTIFIER|<<env_identifier>>|<<command>>) IN (IDENTIFIER|<<env_identifier>>|<<command>>)
                    <<statements>>* END

<while_statement> ::= WHILE (NOT)? (TRUE|FALSE|<<command>>) <<END_OF_LINE>> <<statements>>* END

<switch_statement> ::= SWITCH (<<env_identifier>>|<<command>>|IDENTIFIER) <<END_OF_LINE>> <<case_statement>>* END
<case_statement> ::= CASE (<<string_literal>>|<<command>>) <<statements>>* |
                     DEFAULT <<statements>>*

<exit_function> ::= EXIT <<integer>>?

<path> ::= (IDENTIFIER|"/"|"~"|".")*
<source_function> ::= SOURCE <<path>>
<abbr_function> ::= ABBR <<arguments>>
<set_function> ::= SET <<arguments>>

<builtin_functions> ::= BUILTIN_FUNCTION|(ECHO<<arguments>>)|<<exit_function>>|
                        <<source_function>>|<<abbr_function>>|<<set_function>>  <<END_OF_LINE>>