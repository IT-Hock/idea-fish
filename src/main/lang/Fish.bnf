/*
 * Copyright (c) 2021 - 2022 IT-Hock. All rights reserved
 */
{
  parserClass="de.ithock.idea.fishlang.parser.FishParser"
  parserUtilClass="de.ithock.idea.fishlang.psi.impl.FishParserUtil"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Fish"
  psiImplClassSuffix="Impl"
  psiPackage="de.ithock.idea.fishlang.psi"
  psiImplPackage="de.ithock.idea.fishlang.psi.impl"

  elementTypeHolderClass="de.ithock.idea.fishlang.psi.FishElementTypes"
  elementTypeClass="de.ithock.idea.fishlang.psi.FishElementType"
  tokenTypeClass="de.ithock.idea.fishlang.psi.FishTokenType"

  name = "FishLexer"

 tokens = [
    LINE_COMMENT = "regexp:#(.*)"
    REAL_NUMBER = "regexp:[0-9]+\.[0-9]+"
    // Regexp integer blacklist dot
    INTEGER_NUMBER = "regexp:[0-9]+"

    FUNCTION = "function"
    END = "end"
    ECHO = "echo"
    ELSEIF = "else if"
    IF = "if"
    ELSE = "else"
    FOR = "for"
    IN = "in"
    WHILE = "while"
    SWITCH = "switch"
    CASE = "case"
    BREAK = "break"
    CONTINUE = "continue"
    RETURN = "return"
    TRUE = "true"
    FALSE = "false"

    AND = "&&"
    OR = "||"
    NOT = "!"
    EQ = "=="
    NEQ = "!="
    GT = ">"
    LT = "<"
    GTE = ">="
    LTE = "<="

    SET = "set"
    ABBR = "abbr"

    ENV_IDENTIFIER = "regexp:\$[a-zA-Z_]([a-zA-Z0-9_]|\[[0-9]+])*"
    IDENTIFIER = "regexp:[a-zA-Z0-9_\-\\/]*"
    SINGLE_QUOTED_STRING = "regexp:'[^']*'"
    DOUBLE_QUOTED_STRING = "regexp:\"[^\"]*\""
    //WHITE_SPACE = "regexp:\s+"
    EOL = "\\n, \\r\\n"
  ]
}

FishShell ::= item_*

private item_ ::= (statement_line_comment|VariableDeclaration|NumberLiteral|env_variable|statements|statement_execute|"regexp:\n") {
    pin = 1
}

statement_line_comment ::= LINE_COMMENT
env_variable ::= ENV_IDENTIFIER

private statements ::= (statement_if|statement_for|statment_echo|function_definition|command)

statement_for ::= FOR IDENTIFIER IN IDENTIFIER statements END

statement_if ::= IF command statements (statement_elseif)* (statement_else)? END
statement_elseif ::= ELSEIF command statements
statement_else ::= ELSE item_*
condition ::= Expression (AND|OR|EQ|NEQ|LT|GT|LE|GE) Expression

function_definition ::= FUNCTION (command|IDENTIFIER) statements END

command_arg ::= (('-'|'--') (IDENTIFIER|(IDENTIFIER ' ' IDENTIFIER)|
                SINGLE_QUOTED_STRING|DOUBLE_QUOTED_STRING | INTEGER_NUMBER | REAL_NUMBER | env_variable))|IDENTIFIER

set_command ::= SET (command_arg)
statment_echo ::= ECHO ' '? (SINGLE_QUOTED_STRING|DOUBLE_QUOTED_STRING)
command ::= set_command|((ABBR|IDENTIFIER) (command_arg|IDENTIFIER)*) endOfExpression

statement_execute ::= IDENTIFIER CRLF

VariableDeclaration ::= (IDENTIFIER|env_variable) '=' Expression
Expression ::= (NumberLiteral|env_variable|SINGLE_QUOTED_STRING|DOUBLE_QUOTED_STRING)

RealNumberLiteral ::= REAL_NUMBER
IntegerLiteral ::= INTEGER_NUMBER
NumberLiteral ::= RealNumberLiteral | IntegerLiteral
BooleanLiteral ::= "true" | "false"
StringLiteral ::= SINGLE_QUOTED_STRING | DOUBLE_QUOTED_STRING
ReferenceExpression::= ENV_IDENTIFIER

////////////////////////////////////////////////////////////////////////////////////////////////
private eolStar ::= EOL*
// Must have at least one EOL or SEMICOLON, but at most one SEMICOLON
endOfExpression ::= SEMICOLON | EOL+ { implements = "org.elixir_lang.psi.Unquoted" }
private endOfExpressionMaybe ::= endOfExpression?

private expression ::= emptyParentheses |
                       unmatchedExpression |
                       unqualifiedNoParenthesesManyArgumentsCall
                       { recoverWhile = expressionRecoverWhile }
private expressionRecoverUntil ::= EOL | END
private expressionRecoverWhile ::= !expressionRecoverUntil